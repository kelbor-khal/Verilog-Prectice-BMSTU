[![Typing SVG](https://readme-typing-svg.herokuapp.com?size=30&color=22F723&vCenter=true&lines=%D0%A1omplex+multiplier)](https://git.io/typing-svg)
  
# Оглавление
<div class = "intro">  

1. [Условие](#Условие) 
2. [Анализ](#Анализ) 
3. [Алгоритм](#Алгоритм)  
4. [Временные диаграммы](#Диаграммы)  
5. [Бит-совместимая модель](#модель)  

</div><br>


# Условие  
<p>
Реализовать модуль комплексного умножения. Каждые 4 (3*) такта на вход поступают 2 комплексных числа, размеры действительной и мнимой частей составляют 8 бит, знаковые целые числа. Допускается использовать один физический умножитель. Обосновать размерность результата.
</p>
<br>  

# Анализ
<p>  
На вход поступает набор из 4 коэффициентов, которые характеризуют действительную и мнимую часть двух компелксных чисел соответсвенно.

Первое комплексное число:  
>i1 = a1 + b1 * j  

Второе комлексное число:
>i2 = a2 + b2 * j  

Результат их произведения расчитывается по следующей формуле:
>i1 * i2 = ( a1 * a2 - b1 * b2 ) + ( a1 * b2 + b1 * a2) * i;  

Исходя из получившегося арифметического выражения и условия задания, можно сделать вывод о том, что требуется выполнять последовательно операцию умножения 4 раза.  

</p>
<br>  

# Алгоритм  

<p>
 Алгоритм работы модуля представляет собой следующую последовательность действий:  
</p>

<div class = "intro">  

1. Появление новых данных, выставление сигнала WRITE_NEW_DATA в лог. 1 на один такт;  

2. Вход в умножитель, который характерезуется подъемом сигнала IN_MULT в лог. 1;

1. Вход в цикл, внутри которого выполняется вычисление произведения чисел;  

   1. Каждый такт цикла ( всего 4 такта) инкрементируется счетчик CALK_COUNT;  

   2. В зависимости от значения CALK_COUNT буферных переменным присваиваются
  соотвествующие значения;  

   3. Производится операцию умножения буферных переменных;  

   4. В случае если результат промежуточный (счетчик имеет значение 0 или 2), то результат умножения записывается в буферную переменную. Если же произведение выполняется на 1 и 3 такте цикла, осуществляется сложение или вычитание в зависимости от того какая часть комплексного числа расчитывается;  

   5. Если счетчик равняется 3 и сигнал входя в умножитель имеет значение лог. 1, сигнал VAL_OUT поднимается до лог.1 на один такт.  
    
</div>  

---
<p>
 Для реализации работы алгоритма были введены дополнительные сигналы:  
</p>  

<div class = "intro">  

- WRITE_NEW_DATA - передний фронт данного сигнала разрешает запись новых данных;
- IN_MULT - передний фронт данного сигнала сообщает о входе в умножитель;
- СALK_COUNT - данный сигнал выступает счетчиком внутри операции умножителя;  
- VAL_OUT - сигнал, который появляется после того, как все операции умножения выполнены и данные готовы на выходе. 

</div>  

<br>  

# Диаграммы
<p>
Процесс работы модуля представлен на временных диаграмах ниже:
</p>  

![Временные диаграммы](./frist_task/times_diagrams/time_diagramm.png)

<p>
Результат работы модуля полностью соответсвует заданному начальному условию.
</p>  


<br>  


# Модель
<p>
Бит-совместимая модель была написана на языке программирования C++. Модель, как и модуль получает на вход 4 числа, результат представляет собой 2 числа. Результат работы модели в консоли представлен ниже:  


```shell
ivan@ivan-filin:~/VerilogPractic/First_task$ ./bitCompModel 
Введите мнимую и действительную часть 2 комплексных чисел: 1 9 34 6
Действительная часть числа: -20 
Мнимая часть числа: 312 
ivan@ivan-filin:~/VerilogPractic/First_task$ ./bitCompModel 
Введите мнимую и действительную часть 2 комплексных чисел: 2 10 3 17
Действительная часть числа: -164 
Мнимая часть числа: 64 
ivan@ivan-filin:~/VerilogPractic/First_task$ ./bitCompModel 
Введите мнимую и действительную часть 2 комплексных чисел: 67 35 67 19
Действительная часть числа: 3824 
Мнимая часть числа: 3618 
```
</p>

<p>
Результат работы модели полностью соответсвует заданному начальному условию.
</p>  

<br>  
 
